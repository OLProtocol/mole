
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/davrodpin/mole/cli/cli.go (91.7%)</option>
				
				<option value="file1">github.com/davrodpin/mole/storage/storage.go (78.0%)</option>
				
				<option value="file2">github.com/davrodpin/mole/tunnel/config.go (75.0%)</option>
				
				<option value="file3">github.com/davrodpin/mole/tunnel/key.go (72.5%)</option>
				
				<option value="file4">github.com/davrodpin/mole/tunnel/tunnel.go (84.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "flag"
        "fmt"
        "os"
        "regexp"
        "strings"
)

var re = regexp.MustCompile(`(?P&lt;user&gt;.+@)?(?P&lt;host&gt;[[:alpha:][:digit:]\_\-\.]+)?(?P&lt;port&gt;:[0-9]+)?`)

// App contains main settings of application.
type App struct {
        args []string
        flag *flag.FlagSet

        Command      string
        Local        HostInput
        Remote       HostInput
        Server       HostInput
        Key          string
        Verbose      bool
        Help         bool
        Version      bool
        Alias        string
        Start        string
        AliasDelete  bool
        Detach       bool
        Stop         string
        AliasList    bool
        InsecureMode bool
}

// New creates a new instance of App.
func New(args []string) *App <span class="cov6" title="14">{
        return &amp;App{args: args}
}</span>

// Parse grabs arguments and flags from CLI.
func (c *App) Parse() error <span class="cov6" title="14">{
        f := flag.NewFlagSet("", flag.ExitOnError)
        f.Usage = c.PrintUsage
        c.flag = f

        f.StringVar(&amp;c.Alias, "alias", "", "Create a tunnel alias")
        f.BoolVar(&amp;c.AliasDelete, "delete", false, "delete a tunnel alias (must be used with -alias)")
        f.BoolVar(&amp;c.AliasList, "aliases", false, "list all aliases")
        f.StringVar(&amp;c.Start, "start", "", "Start a tunnel using a given alias")
        f.Var(&amp;c.Local, "local", "(optional) Set local endpoint address: [&lt;host&gt;]:&lt;port&gt;")
        f.Var(&amp;c.Remote, "remote", "set remote endpoint address: [&lt;host&gt;]:&lt;port&gt;")
        f.Var(&amp;c.Server, "server", "set server address: [&lt;user&gt;@]&lt;host&gt;[:&lt;port&gt;]")
        f.StringVar(&amp;c.Key, "key", "", "(optional) Set server authentication key file path")
        f.BoolVar(&amp;c.Verbose, "v", false, "(optional) Increase log verbosity")
        f.BoolVar(&amp;c.Help, "help", false, "list all options available")
        f.BoolVar(&amp;c.Version, "version", false, "display the mole version")
        f.BoolVar(&amp;c.Detach, "detach", false, "(optional) run process in background")
        f.StringVar(&amp;c.Stop, "stop", "", "stop background process")
        f.BoolVar(&amp;c.InsecureMode, "insecure", false, "(optional) skip host key validation when connecting to ssh server")

        f.Parse(c.args[1:])

        if c.Help </span><span class="cov1" title="1">{
                c.Command = "help"
        }</span> else<span class="cov6" title="13"> if c.Version </span><span class="cov1" title="1">{
                c.Command = "version"
        }</span> else<span class="cov6" title="12"> if c.AliasList </span><span class="cov1" title="1">{
                c.Command = "aliases"
        }</span> else<span class="cov5" title="11"> if c.Alias != "" &amp;&amp; c.AliasDelete </span><span class="cov1" title="1">{
                c.Command = "rm-alias"
        }</span> else<span class="cov5" title="10"> if c.Alias != "" </span><span class="cov5" title="7">{
                c.Command = "new-alias"
        }</span> else<span class="cov3" title="3"> if c.Start != "" </span><span class="cov1" title="1">{
                c.Command = "start-from-alias"
                c.Alias = c.Start
        }</span> else<span class="cov2" title="2"> if c.Stop != "" </span><span class="cov0" title="0">{
                c.Command = "stop"
        }</span> else<span class="cov2" title="2"> {
                c.Command = "start"
        }</span>

        <span class="cov6" title="14">err := c.Validate()
        if err != nil </span><span class="cov4" title="6">{
                return err
        }</span>

        <span class="cov5" title="8">return nil</span>
}

// Validate checks parsed params.
func (c App) Validate() error <span class="cov7" title="21">{
        if len(c.args[1:]) == 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("not enough arguments provided")
        }</span>

        <span class="cov7" title="19">switch c.Command </span>{
        case "new-alias":<span class="cov6" title="13">
                if c.Remote.String() == "" </span><span class="cov4" title="6">{
                        return fmt.Errorf("required flag is missing: -remote")
                }</span> else<span class="cov5" title="7"> if c.Server.String() == "" </span><span class="cov3" title="4">{
                        return fmt.Errorf("required flag is missing: -server")
                }</span>
        case "start":<span class="cov1" title="1">
                if c.Server.String() == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("required flag is missing: -server")
                }</span>

        }
        <span class="cov5" title="9">return nil</span>
}

// PrintUsage prints, to the standard output, the informational text on how to
// use the tool.
func (c *App) PrintUsage() <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "%s\n\n", `usage:
        mole [-v] [-insecure] [-detach] [-local [&lt;host&gt;]:&lt;port&gt;] -remote [&lt;host&gt;]:&lt;port&gt; -server [&lt;user&gt;@]&lt;host&gt;[:&lt;port&gt;] [-key &lt;key_path&gt;]
        mole -alias &lt;alias_name&gt; [-v] [-local [&lt;host&gt;]:&lt;port&gt;] -remote [&lt;host&gt;]:&lt;port&gt; -server [&lt;user&gt;@]&lt;host&gt;[:&lt;port&gt;] [-key &lt;key_path&gt;]
        mole -alias &lt;alias_name&gt; -delete
        mole -start &lt;alias_name&gt;
        mole -help
        mole -version`)
        c.flag.PrintDefaults()
}</span>

// String returns a string representation of an App.
func (c App) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[local=%s, remote=%s, server=%s, key=%s, verbose=%t, help=%t, version=%t, detach=%t]",
                c.Local, c.Remote, c.Server, c.Key, c.Verbose, c.Help, c.Version, c.Detach)
}</span>

// HostInput holds information about a host
type HostInput struct {
        User string
        Host string
        Port string
}

// String returns a string representation of a HostInput
func (h HostInput) String() string <span class="cov9" title="63">{
        var s string
        if h.User == "" </span><span class="cov9" title="63">{
                s = h.Address()
        }</span> else<span class="cov0" title="0"> {
                s = fmt.Sprintf("%s@%s", h.User, h.Address())
        }</span>

        <span class="cov9" title="63">return s</span>
}

// Set parses a string representation of HostInput into its proper attributes.
func (h *HostInput) Set(value string) error <span class="cov7" title="19">{
        result := parseServerInput(value)
        h.User = strings.Trim(result["user"], "@")
        h.Host = result["host"]
        h.Port = strings.Trim(result["port"], ":")

        return nil
}</span>

// Address returns a string representation of HostInput to be used to perform
// network connections.
func (h HostInput) Address() string <span class="cov9" title="63">{
        if h.Port == "" </span><span class="cov9" title="56">{
                return fmt.Sprintf("%s", h.Host)
        }</span>

        <span class="cov5" title="7">return fmt.Sprintf("%s:%s", h.Host, h.Port)</span>
}

func parseServerInput(input string) map[string]string <span class="cov7" title="19">{
        match := re.FindStringSubmatch(input)
        result := make(map[string]string)
        for i, name := range re.SubexpNames() </span><span class="cov10" title="76">{
                if i == 0 </span><span class="cov7" title="19">{
                        continue</span>
                }

                <span class="cov9" title="57">result[name] = match[i]</span>
        }

        <span class="cov7" title="19">return result</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package storage

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"

        "github.com/BurntSushi/toml"
)

// Store contains the map of tunnels, where key is string tunnel alias and value is Tunnel.
type Store struct {
        Tunnels map[string]*Tunnel `toml:"tunnels"`
}

// Tunnel represents settings of the ssh tunnel.
type Tunnel struct {
        Local   string `toml:"local"`
        Remote  string `toml:"remote"`
        Server  string `toml:"server"`
        Key     string `toml:"key"`
        Verbose bool   `toml:"verbose"`
        Help    bool   `toml:"help"`
        Version bool   `toml:"version"`
        Detach  bool   `toml:"detach"`
}

func (t Tunnel) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[local=%s, remote=%s, server=%s, key=%s, verbose=%t, help=%t, version=%t, detach=%t]",
                t.Local, t.Remote, t.Server, t.Key, t.Verbose, t.Help, t.Version, t.Detach)
}</span>

// Save stores Tunnel to the Store.
func Save(name string, tunnel *Tunnel) (*Tunnel, error) <span class="cov5" title="4">{
        store, err := loadStore()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while loading mole configuration: %v", err)
        }</span>

        <span class="cov5" title="4">store.Tunnels[name] = tunnel

        _, err = createStore(store)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while saving mole configuration: %v", err)
        }</span>

        <span class="cov5" title="4">return tunnel, nil</span>
}

// FindByName finds the Tunnel in Store by name.
func FindByName(name string) (*Tunnel, error) <span class="cov3" title="2">{
        store, err := loadStore()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while loading mole configuration: %v", err)
        }</span>

        <span class="cov3" title="2">tun := store.Tunnels[name]

        if tun == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("alias could not be found: %s", name)
        }</span>

        <span class="cov1" title="1">return tun, nil</span>
}

// FindAll finds all the Tunnels in Store.
func FindAll() (map[string]*Tunnel, error) <span class="cov1" title="1">{
        store, err := loadStore()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while loading mole configuration: %v", err)
        }</span>

        <span class="cov1" title="1">return store.Tunnels, nil</span>
}

// Remove deletes Tunnel from the Store by name.
func Remove(name string) (*Tunnel, error) <span class="cov1" title="1">{
        store, err := loadStore()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while loading mole configuration: %v", err)
        }</span>

        <span class="cov1" title="1">tun := store.Tunnels[name]

        if tun != nil </span><span class="cov1" title="1">{
                delete(store.Tunnels, name)
                _, err := createStore(store)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov1" title="1">return tun, nil</span>
}

func loadStore() (*Store, error) <span class="cov7" title="8">{
        var store *Store

        if _, err := os.Stat(storePath()); err != nil </span><span class="cov1" title="1">{
                store = &amp;Store{Tunnels: make(map[string]*Tunnel)}
                store, err = createStore(store)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">return store, nil</span>
        }

        <span class="cov6" title="7">if _, err := toml.DecodeFile(storePath(), &amp;store); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="7">return store, nil</span>
}

func createStore(store *Store) (*Store, error) <span class="cov6" title="6">{
        f, err := os.Create(storePath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="6">defer f.Close()

        b := bufio.NewWriter(f)
        e := toml.NewEncoder(b)

        if err := e.Encode(&amp;store); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="6">return store, nil</span>
}

func storePath() string <span class="cov10" title="21">{
        return filepath.Join(os.Getenv("HOME"), ".mole.conf")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package tunnel

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/kevinburke/ssh_config"
        log "github.com/sirupsen/logrus"
)

// SSHConfigFile finds specific attributes of a ssh server configured on a
// ssh config file.
type SSHConfigFile struct {
        sshConfig *ssh_config.Config
}

// NewSSHConfigFile creates a new instance of SSHConfigFile based on the
// ssh config file from $HOME/.ssh/config.
func NewSSHConfigFile() (*SSHConfigFile, error) <span class="cov9" title="12">{
        configPath := filepath.Join(os.Getenv("HOME"), ".ssh", "config")
        f, err := os.Open(filepath.Clean(configPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="12">cfg, err := ssh_config.Decode(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="12">log.Debugf("using ssh config file from: %s", configPath)

        return &amp;SSHConfigFile{sshConfig: cfg}, nil</span>
}

// Get consults a ssh config file to extract some ssh server attributes
// from it, returning a SSHHost. Any attribute which its value is an empty
// string is an attribute that could not be found in the ssh config file.
func (r SSHConfigFile) Get(host string) *SSHHost <span class="cov10" title="15">{
        hostname := r.getHostname(host)

        port, err := r.sshConfig.Get(host, "Port")
        if err != nil </span><span class="cov0" title="0">{
                port = ""
        }</span>

        <span class="cov10" title="15">user, err := r.sshConfig.Get(host, "User")
        if err != nil </span><span class="cov0" title="0">{
                user = ""
        }</span>

        <span class="cov10" title="15">localForward, err := r.getLocalForward(host)
        if err != nil </span><span class="cov0" title="0">{
                localForward = &amp;LocalForward{Local: "", Remote: ""}
                log.Warningf("error reading LocalForward configuration from ssh config file. This option will not be used: %v", err)
        }</span>

        <span class="cov10" title="15">key := r.getKey(host)

        return &amp;SSHHost{
                Hostname:     hostname,
                Port:         port,
                User:         user,
                Key:          key,
                LocalForward: localForward,
        }</span>
}

func (r SSHConfigFile) getHostname(host string) string <span class="cov10" title="15">{
        hostname, err := r.sshConfig.Get(host, "Hostname")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov10" title="15">return hostname</span>
}

func (r SSHConfigFile) getLocalForward(host string) (*LocalForward, error) <span class="cov10" title="15">{
        var local, remote string

        c, err := r.sshConfig.Get(host, "LocalForward")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="15">if c == "" </span><span class="cov9" title="13">{
                return &amp;LocalForward{Local: "", Remote: ""}, nil
        }</span>

        <span class="cov3" title="2">l := strings.Fields(c)

        if len(l) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bad forwarding specification on ssh config file: %s", l)
        }</span>

        <span class="cov3" title="2">local = l[0]
        remote = l[1]

        if strings.HasPrefix(local, ":") </span><span class="cov0" title="0">{
                local = fmt.Sprintf("127.0.0.1%s", local)
        }</span>

        <span class="cov3" title="2">if local != "" &amp;&amp; !strings.Contains(local, ":") </span><span class="cov3" title="2">{
                local = fmt.Sprintf("127.0.0.1:%s", local)
        }</span>

        <span class="cov3" title="2">return &amp;LocalForward{Local: local, Remote: remote}, nil</span>

}

func (r SSHConfigFile) getKey(host string) string <span class="cov10" title="15">{
        id, err := r.sshConfig.Get(host, "IdentityFile")

        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov10" title="15">if id != "" </span><span class="cov6" title="6">{
                if strings.HasPrefix(id, "~") </span><span class="cov6" title="5">{
                        return filepath.Join(os.Getenv("HOME"), id[1:])
                }</span>

                <span class="cov1" title="1">return id</span>
        }

        <span class="cov8" title="9">return ""</span>
}

// SSHHost represents a host configuration extracted from a ssh config file.
type SSHHost struct {
        Hostname     string
        Port         string
        User         string
        Key          string
        LocalForward *LocalForward
}

// String returns a string representation of a SSHHost.
func (h SSHHost) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[hostname=%s, port=%s, user=%s, key=%s, local_forward=%s]", h.Hostname, h.Port, h.User, h.Key, h.LocalForward)
}</span>

// LocalForward represents a LocalForward configuration for SSHHost.
type LocalForward struct {
        Local  string
        Remote string
}

// String returns a string representation of LocalForward.
func (f LocalForward) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[local=%s, remote=%s]", f.Local, f.Remote)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package tunnel

import (
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "io/ioutil"

        "github.com/awnumar/memguard"
        "golang.org/x/crypto/ssh"
)

// PemKeyParser translates pem keys to a signature signer.
type PemKeyParser interface {
        // Parse returns a key signer to create signatures that verify against a
        // public key.
        Parse() (*ssh.Signer, error)
}

// PemKey holds data related to PEM keys
type PemKey struct {
        // Data holds the data for a PEM private key
        Data []byte

        // passphrase used to parse a PEM encoded private key
        passphrase *memguard.LockedBuffer
}

func NewPemKey(keyPath, passphrase string) (*PemKey, error) <span class="cov10" title="11">{
        data, err := ioutil.ReadFile(keyPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="11">k := &amp;PemKey{Data: data}

        if passphrase != "" </span><span class="cov1" title="1">{
                err = k.updatePassphrase([]byte(passphrase))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov10" title="11">return k, nil</span>
}

// IsEncrypted inspects the key data block to tell if it is whether encrypted
// or not.
func (k PemKey) IsEncrypted() (bool, error) <span class="cov9" title="10">{
        p, err := decodePemKey(k.Data)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov9" title="10">return x509.IsEncryptedPEMBlock(p), nil</span>
}

// Parse translates a pem key to a signer to create signatures that verify
// against a public key.
func (k *PemKey) Parse() (ssh.Signer, error) <span class="cov6" title="4">{
        var signer ssh.Signer

        enc, err := k.IsEncrypted()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="4">if enc </span><span class="cov1" title="1">{
                if len(k.passphrase.Buffer()) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("can't read protected ssh key because no passphrase was not provided")
                }</span>

                <span class="cov1" title="1">signer, err = ssh.ParsePrivateKeyWithPassphrase(k.Data, k.passphrase.Buffer())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov5" title="3"> {
                signer, err = ssh.ParsePrivateKey(k.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov6" title="4">return signer, nil</span>
}

// HandlePassphrase securely records a passphrase given by a callback to the
// memory.
func (pk *PemKey) HandlePassphrase(handler func() ([]byte, error)) error <span class="cov3" title="2">{
        enc, err := pk.IsEncrypted()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while reading ssh key: %v", err)
        }</span>

        <span class="cov3" title="2">if !enc </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">pp, err := handler()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while reading password: %v", err)
        }</span>

        <span class="cov1" title="1">pk.updatePassphrase(pp)

        return nil</span>
}

func (pk *PemKey) updatePassphrase(pp []byte) error <span class="cov3" title="2">{
        if pk.passphrase == nil </span><span class="cov3" title="2">{
                lb, err := memguard.NewImmutableFromBytes([]byte(pp))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov3" title="2">pk.passphrase = lb</span>
        } else<span class="cov0" title="0"> {
                if err := pk.passphrase.Move(pp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

func decodePemKey(data []byte) (*pem.Block, error) <span class="cov9" title="10">{
        p, r := pem.Decode(data)

        if p == nil &amp;&amp; len(r) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while parsing key: no PEM data found")
        }</span>

        <span class="cov9" title="10">if len(r) != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("extra data in encoded key")
        }</span>

        <span class="cov9" title="10">return p, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package tunnel

import (
        "fmt"
        "io"
        "net"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        log "github.com/sirupsen/logrus"
        "golang.org/x/crypto/ssh"
        "golang.org/x/crypto/ssh/knownhosts"
)

const (
        HostMissing = "server host has to be provided as part of the server address"
)

// Server holds the SSH Server attributes used for the client to connect to it.
type Server struct {
        Name    string
        Address string
        User    string
        Key     *PemKey
        // Insecure is a flag to indicate if the host keys should be validated.
        Insecure bool
}

// NewServer creates a new instance of Server using $HOME/.ssh/config to
// resolve the missing connection attributes (e.g. user, hostname, port and
// key) required to connect to the remote server, if any.
func NewServer(user, address, key string) (*Server, error) <span class="cov10" title="8">{
        var host string
        var hostname string
        var port string

        host = address
        if strings.Contains(host, ":") </span><span class="cov7" title="4">{
                args := strings.Split(host, ":")
                host = args[0]
                port = args[1]
        }</span>

        <span class="cov10" title="8">c, err := NewSSHConfigFile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error accessing %s: %v", host, err)
        }</span>

        <span class="cov10" title="8">h := c.Get(host)
        hostname = reconcileHostname(host, h.Hostname)
        port = reconcilePort(port, h.Port)
        user = reconcileUser(user, h.User)
        key = reconcileKey(key, h.Key)

        if host == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf(HostMissing)
        }</span>

        <span class="cov9" title="7">if hostname == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no server hostname (ip) could be found for server %s", host)
        }</span>

        <span class="cov9" title="7">if port == "" </span><span class="cov0" title="0">{
                port = "22"
        }</span>

        <span class="cov9" title="7">if user == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user could be found for server %s", host)
        }</span>

        <span class="cov9" title="7">if key == "" </span><span class="cov4" title="2">{
                key = filepath.Join(os.Getenv("HOME"), ".ssh", "id_rsa")
        }</span>

        <span class="cov9" title="7">pk, err := NewPemKey(key, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error while reading key %s: %v", key, err)
        }</span>

        <span class="cov9" title="7">return &amp;Server{
                Name:    host,
                Address: fmt.Sprintf("%s:%s", hostname, port),
                User:    user,
                Key:     pk,
        }, nil</span>
}

// String provided a string representation of a Server.
func (s Server) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[name=%s, address=%s, user=%s]", s.Name, s.Address, s.User)
}</span>

// Tunnel represents the ssh tunnel used to forward a local connection to a
// a remote endpoint through a ssh server.
type Tunnel struct {
        // Ready tells when the Tunnel is ready to accept connections
        Ready    chan bool
        local    string
        server   *Server
        remote   string
        done     chan error
        client   *ssh.Client
        listener net.Listener
}

// New creates a new instance of Tunnel.
func New(localAddress string, server *Server, remoteAddress string) *Tunnel <span class="cov7" title="4">{
        cfg, err := NewSSHConfigFile()
        if err != nil </span><span class="cov0" title="0">{
                log.Warningf("error to read ssh config: %v", err)
        }</span>

        <span class="cov7" title="4">sh := cfg.Get(server.Name)
        localAddress = reconcileLocal(localAddress, sh.LocalForward.Local)
        remoteAddress = reconcileRemote(remoteAddress, sh.LocalForward.Remote)

        return &amp;Tunnel{
                Ready:  make(chan bool, 1),
                local:  localAddress,
                server: server,
                remote: remoteAddress,
                done:   make(chan error),
        }</span>
}

// Start creates a new ssh tunnel, allowing data exchange between the local and
// remote endpoints.
func (t *Tunnel) Start() error <span class="cov5" title="3">{
        var once sync.Once

        _, err := t.Listen()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov5" title="3">defer t.listener.Close()

        log.Debugf("tunnel: %s", t)

        log.WithFields(log.Fields{
                "local_address": t.local,
        }).Info("listening on local address")

        go func(t *Tunnel) </span><span class="cov5" title="3">{
                for </span><span class="cov7" title="5">{

                        once.Do(func() </span><span class="cov5" title="3">{
                                t.Ready &lt;- true
                        }</span>)

                        <span class="cov7" title="5">conn, err := t.listener.Accept()
                        if err != nil </span><span class="cov5" title="3">{
                                t.done &lt;- fmt.Errorf("error while establishing new connection: %v", err)
                                return
                        }</span>

                        <span class="cov4" title="2">log.WithFields(log.Fields{
                                "address": conn.RemoteAddr(),
                        }).Debug("new connection")

                        err = t.forward(conn)
                        if err != nil </span><span class="cov0" title="0">{
                                t.done &lt;- err
                                return
                        }</span>
                }
        }(t)

        <span class="cov5" title="3">select </span>{
        case err = &lt;-t.done:<span class="cov5" title="3">
                if t.client != nil </span><span class="cov5" title="3">{
                        t.client.Conn.Close()
                }</span>
                <span class="cov5" title="3">return err</span>
        }
}

// Listen binds the local address configured on Tunnel.
func (t *Tunnel) Listen() (net.Listener, error) <span class="cov5" title="3">{

        if t.listener != nil </span><span class="cov0" title="0">{
                return t.listener, nil
        }</span>

        <span class="cov5" title="3">local, err := net.Listen("tcp", t.local)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="3">t.listener = local
        t.local = local.Addr().String()

        return t.listener, nil</span>
}

func (t *Tunnel) forward(localConn net.Conn) error <span class="cov4" title="2">{
        remoteConn, err := t.proxy()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">go copyConn(localConn, remoteConn)
        go copyConn(remoteConn, localConn)

        return nil</span>
}

// Stop cancels the tunnel, closing all connections.
func (t Tunnel) Stop() <span class="cov4" title="2">{
        t.done &lt;- nil
}</span>

// String returns a string representation of a Tunnel.
func (t Tunnel) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[local:%s, server:%s, remote:%s]", t.local, t.server.Address, t.remote)
}</span>

func (t *Tunnel) proxy() (net.Conn, error) <span class="cov4" title="2">{
        c, err := sshClientConfig(*t.server)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error generating ssh client config: %s", err)
        }</span>

        <span class="cov4" title="2">if t.client == nil </span><span class="cov4" title="2">{
                t.client, err = ssh.Dial("tcp", t.server.Address, c)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server dial error: %s", err)
                }</span>

                <span class="cov4" title="2">log.WithFields(log.Fields{
                        "server": t.server,
                }).Debug("new connection established to server")</span>

        }

        <span class="cov4" title="2">remoteConn, err := t.client.Dial("tcp", t.remote)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("remote dial error: %s", err)
        }</span>

        <span class="cov4" title="2">log.WithFields(log.Fields{
                "remote": t.remote,
                "server": t.server,
        }).Debug("new connection established to remote")

        return remoteConn, nil</span>
}

func sshClientConfig(server Server) (*ssh.ClientConfig, error) <span class="cov4" title="2">{
        signer, err := server.Key.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">clb, err := knownHostsCallback(server.Insecure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return &amp;ssh.ClientConfig{
                User: server.User,
                Auth: []ssh.AuthMethod{
                        ssh.PublicKeys(signer),
                },
                HostKeyCallback: clb,
                Timeout:         3 * time.Second,
        }, nil</span>
}

func copyConn(writer, reader net.Conn) <span class="cov7" title="4">{
        _, err := io.Copy(writer, reader)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%v", err)
        }</span>
}

func knownHostsCallback(insecure bool) (ssh.HostKeyCallback, error) <span class="cov4" title="2">{
        var clb func(hostname string, remote net.Addr, key ssh.PublicKey) error

        if insecure </span><span class="cov1" title="1">{
                clb = func(hostname string, remote net.Addr, key ssh.PublicKey) error </span><span class="cov1" title="1">{
                        return nil
                }</span>
        } else<span class="cov1" title="1"> {
                var err error
                knownHostFile := filepath.Join(os.Getenv("HOME"), ".ssh", "known_hosts")
                log.Debugf("known_hosts file used: %s", knownHostFile)

                clb, err = knownhosts.New(knownHostFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error while parsing 'known_hosts' file: %s: %v", knownHostFile, err)
                }</span>
        }

        <span class="cov4" title="2">return clb, nil</span>
}

func reconcileHostname(givenHostname, resolvedHostname string) string <span class="cov10" title="8">{
        if resolvedHostname != "" </span><span class="cov7" title="4">{
                return resolvedHostname
        }</span>

        <span class="cov7" title="4">if resolvedHostname == "" &amp;&amp; givenHostname != "" </span><span class="cov5" title="3">{
                return givenHostname
        }</span>

        <span class="cov1" title="1">return ""</span>
}

func reconcilePort(givenPort, resolvedPort string) string <span class="cov10" title="8">{
        if givenPort != "" </span><span class="cov7" title="4">{
                return givenPort
        }</span>

        <span class="cov7" title="4">if givenPort == "" &amp;&amp; resolvedPort != "" </span><span class="cov5" title="3">{
                return resolvedPort
        }</span>

        <span class="cov1" title="1">return ""</span>
}

func reconcileUser(givenUser, resolvedUser string) string <span class="cov10" title="8">{
        if givenUser != "" </span><span class="cov7" title="4">{
                return givenUser
        }</span>

        <span class="cov7" title="4">if givenUser == "" &amp;&amp; resolvedUser != "" </span><span class="cov5" title="3">{
                return resolvedUser
        }</span>

        <span class="cov1" title="1">return ""</span>
}

func reconcileKey(givenKey, resolvedKey string) string <span class="cov10" title="8">{
        if givenKey != "" </span><span class="cov4" title="2">{
                return givenKey
        }</span>

        <span class="cov8" title="6">if givenKey == "" &amp;&amp; resolvedKey != "" </span><span class="cov5" title="3">{
                return resolvedKey
        }</span>

        <span class="cov5" title="3">return ""</span>
}

func reconcileLocal(givenLocal, resolvedLocal string) string <span class="cov7" title="4">{

        if givenLocal == "" &amp;&amp; resolvedLocal != "" </span><span class="cov0" title="0">{
                return resolvedLocal
        }</span>
        <span class="cov7" title="4">if givenLocal == "" </span><span class="cov4" title="2">{
                return "127.0.0.1:0"
        }</span>
        <span class="cov4" title="2">if strings.HasPrefix(givenLocal, ":") </span><span class="cov1" title="1">{
                return fmt.Sprintf("127.0.0.1%s", givenLocal)
        }</span>

        <span class="cov1" title="1">return givenLocal</span>
}

func reconcileRemote(givenRemote, resolvedRemote string) string <span class="cov7" title="4">{

        if givenRemote == "" &amp;&amp; resolvedRemote != "" </span><span class="cov0" title="0">{
                return resolvedRemote
        }</span>
        <span class="cov7" title="4">if strings.HasPrefix(givenRemote, ":") </span><span class="cov1" title="1">{
                return fmt.Sprintf("127.0.0.1%s", givenRemote)
        }</span>

        <span class="cov5" title="3">return givenRemote</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
